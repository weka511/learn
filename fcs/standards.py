# Copyright (C) 2020 Greenweaves Software Limited

# This is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This software is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>

# Functions to look up reference standards

import os, re

# create_standards
#
# Read the values that are represented in all standards files in specified path
#
# Parameters:
#      path     Where standards file lives
#
# Returns:
#      list  [...(barcode,[standards])...]

def create_standards(path=r'C:\data\properties'):
    # extract
    #
    # Find value associated with key in a specific line
    #
    # Parameters:
    #      line A line read from properties file
    #      key  Look for this key in line
    #
    # Returns:
    #      value associated with key (or None)
    
    def extract(line,key):
        if line.startswith(key):
            pos = len(key)
            while line[pos] in [' ','=']:
                pos+=1
            return line[pos:]
        return None
    
    product = []
    for file in os.listdir(path):
        if not file.endswith('.properties'): continue
        beadset      = file[:3]
        full_barcode = None        
        with open(os.path.join(path,file)) as f:
            for line in f: # Extract two key value pairs
                barcode_number = extract(line.strip(),'constants.Beadset.Barcodes')
                if barcode_number!=None:
                    full_barcode = beadset + barcode_number
                    continue
                standards = extract(line.strip(),'constants.Beadset.Standards')
                if standards!=None:
                    values = [float(c) for c in standards.split(',')]
                    product.append((full_barcode,values))
    return product

# lookup
#
# Determine standards for specified barcode: the beadset must match; we want the supplied barcode 
# digits to be greater or equal to the barcode digits in the properties file; and this must be the 
# eraliest proerties file that satisfies the other two requirements.
#
# Parameters:
#     barcode    Barcode from plate
#     standards  List generated by: create_standards(...)
#
# Returns: the standards to be used for supplied barcode

def lookup(barcode,standards):
    m = re.match('((RTI)|(PAP))[A-Z]*([0-9]+)',barcode)
    if m:
        beadset = m.group(1)
        n = m.group(4)
        candidates = sorted([(k,v) for (k,v) in standards if beadset==k[:3] and k[3:]<=n])
        if len(candidates)>0:
            return candidates[-1]

        return None

if __name__=='__main__':
    standards = create_standards()
    print (standards)
    print (lookup('PAP15100001',standards))
    print (lookup('PAP90200082',standards))
    print (lookup('RTICT16100019',standards))